<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, user-scalable=no" />
        <link rel="shortcut icon" type="image/png" href="favicon.png">
        <title>Inscribe the planet</title>
        <style>
            * {
                box-sizing: border-box;
                font-size: 1.15rem;
                font-family: monospace;
                background-color: black;
                color: white;
            }
            html {
                max-width: 70ch;
                padding: 3rem 1rem;
                margin: auto;
                line-height: 1.25;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            input {
                line-height: 1.25;
                width: 100%;
                height: 1.8rem;
                font-size: 1.15rem;
                border: 1px solid white;
            }
            .black-bg{
                display:none;
                width:100%;
                position:fixed;
                top:0;
                left:0;
                background-color:black;
                opacity:.5;
                width:100vw;
                height:100vh;
            }
            .modal{
                display:none;
                position:fixed;
                box-sizing:border-box;
                top:50%;
                left:50%;
                transform:translate(-50%,-50%);
                width:100%;
                max-width:560px;
                background-color:white;
                border-radius:10px;
                padding:20px;
                color:black;
                text-align:center;
            }
            .display {
                display: none;
                border: 1px solid white;
                padding: 1rem;
                border-radius: 1rem;
                word-wrap: break-word;
                text-align: center;
                position: relative;
            }
            .display p {
                text-align: left;
            }
            .checking_mempool, .checking_mempool span {
                color: lightgreen;
            }
            .feerates {
                display: flex;
                justify-content: space-around;
            }
            .fee {
                width: 100%;
                max-width: 6rem;
                margin: 0px 0.5rem;
                text-align: center;
                cursor: pointer;
            }
            .fee .num {
                background-color: grey;
                border: 1px solid white;
                padding: .3rem;
            }
            .maxfee .num {
                background-color: green;
            }
            .safari_warning {
                display: none;
            }
            @media screen and (max-width: 600px) {
            }
        </style>

<script src="https://unpkg.com/buffer-es@1.0.0/buffer.js"></script>
<script src="/nostr.js"></script>

        <script type="module">import "/bitcoinjs-lib.js"</script>
        <script type="module">import "/ecpair.js"</script>


<script src="https://unpkg.com/@cmdcode/bton@1.0.4"></script>
        <script> var BTON = window.bton </script>
        <script src="https://unpkg.com/@cmdcode/crypto-utils@1.6.0"></script>
        <script src="https://bundle.run/bech32@2.0.0"></script>
        <script src="https://supertestnet.github.io/bitcoin-chess/js/qrcode.js"></script>
        <script src="secp256k1.js"></script>
        <script>
         
            const isProduction = !location.href.includes('signet')
const ordinalsExplorerUrl = isProduction ? "http://staccstacc.eastus.cloudapp.azure.com" : "https://explorer-signet.openordex.org"
const baseMempoolUrl = isProduction ? "https://mempool.space" : "https://mempool.space/signet"
const networkName = isProduction ? "mainnet" : "signet"
const baseMempoolApiUrl = `${baseMempoolUrl}/api`
const bitcoinPriceApiUrl = "https://blockchain.info/ticker?cors=true"

            const nostrRelayUrl = 'wss://nostr.openordex.org'
const collectionsRepo = "ordinals-wallet/ordinals-collections"
const exchangeName = 'candyMachine'
const feeLevel = "hourFee" // "fastestFee" || "halfHourFee" || "hourFee" || "economyFee" || "minimumFee"
const nostrOrderEventKind = 803

            var bitcoin = window.bitcoin
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = new URLSearchParams( window.location.search );
            var url_keys = url_params.keys();
            var $_GET = {}
            for ( var key of url_keys ) $_GET[ key ] = url_params.get( key );
            
async function getTxHexById(txId) {
    let baseMempoolApiUrl = "https://mempool.space/api"
       let txIdid = await fetch(`${baseMempoolApiUrl}/tx/${txId}/hex`)
            .then(response => response.text())


    return txIdid
}
        </script>
        <script>
            function hexToUint8Array(hex) {
  const length = hex.length / 2;
  const result = new Uint8Array(length);
  
  for (let i = 0; i < length; i++) {
    const byte = parseInt(hex.substr(i * 2, 2), 16);
    result[i] = byte;
  }

  return result;
}

async function getAddressUtxos(address) {

let baseMempoolApiUrl = "https://mempool.space/api"
    return await fetch(`${baseMempoolApiUrl}/address/${address}/utxo`)
        .then(response => response.json())
}

function btcToSat(btc) {
    return Math.floor(Number(btc) * Math.pow(10, 8))
}

function satToBtc(sat) {
    return Number(sat) / Math.pow(10, 8)
}
async function doesUtxoContainInscription(utxo) {
    const html = await fetch(`${ordinalsExplorerUrl}/output/${utxo.txid}:${utxo.vout}`)
        .then(response => response.text())

    return html.match(/class=thumbnails/) !== null
}

async function isInscriptionOffsetLessThanDust(inscription) {
    return inscriptionOffset < 546
}

function calculateFee(vins, vouts, recommendedFeeRate, includeChangeOutput = true) {
    const baseTxSize = 10
    const inSize = 180
    const outSize = 34

    const txSize = baseTxSize + (vins * inSize) + (vouts * outSize) + (includeChangeOutput * outSize)
    const fee = txSize * recommendedFeeRate

    return fee
}

async function selectUtxos(utxos, amount, vins, vouts, recommendedFeeRate) {
    takerUtxos = []
    paddingUtxos = []
    takerUtxos.length = 0
    paddingUtxos.length = 0
    let takerUtxosAmount = 0
    let paddingUtxosAmount = 0
    let additionalVouts = 0
    let takerPaddingRequired = false
    let estimatedFee = 0
    // Sort descending by value greater than amount
    utxos = utxos.filter(x => x.value).sort((a, b) => b.value - a.value)

    for (const utxo of utxos) {

        estimatedFee = calculateFee(vins + takerUtxos.length + paddingUtxos.length, vouts + additionalVouts, recommendedFeeRate)

       if (takerUtxosAmount < amount) {
            takerUtxos.push(utxo)
            takerUtxosAmount += utxo.value
            additionalVouts++
        }

        if (amount < takerUtxosAmount ) {
            break
        }

    }


    return [takerUtxos, paddingUtxos]
}
function appendSighashType(signature, sighashType) {
  const extendedSignature = new Uint8Array(signature.length + 1);
  extendedSignature.set(signature);
  extendedSignature[signature.length] = sighashType;
  return extendedSignature;
}

async function findPaymentUTXO(utxos) {
  
  // Find a suitable UTXO for the payment (e.g., the first one or the one with enough balance)
  const paymentUTXO = utxos[0];
  
  return {
    paymentTxid: paymentUTXO.txid,
    paymentVout: paymentUTXO.vout,
    fundingAmount: paymentUTXO.value,
  };
}
let  from 

function estimateTxSize(inputsCount, outputsCount, feeRate) {
  const inputSize = 148;
  const outputSize = 34;
  const overheadSize = 10;

  const totalSize = overheadSize + (inputsCount * inputSize) + (outputsCount * outputSize);
  const fee = totalSize * feeRate;

  return fee;
}

            async function generatePSBTListingInscriptionForSale(KeyPair, fundingAddress, ordinalUtxoTxId, ordinalUtxoVout, amt, price, paymentAddress, tapkey, leaf, decodedToAddress, decodedFundingAddress, fee, seckey, script, cblock) {
                var bitcoin = window.bitcoin    
                bitcoin.initEccLib(secp256k1)
from = await getWalletAddress()
var scriptPubKeyFrom = bitcoin.address.toOutputScript(from, bitcoin.networks.bitcoin)
          
                var redeemtx = {
                  version: 2,
                  input: [{
                    txid: ordinalUtxoTxId,
                    vout: ordinalUtxoVout,
                    prevout: { value: amt, scriptPubKey: '5120' + tapkey },
                    witness: []
                  },
                ],
                  output:[{
                    value: amt - fee,
                    scriptPubKey: decodedToAddress
                  }],
                  locktime: 0
                }
                var sec = await BTON.Tap.getSeckey(seckey.raw, [ leaf ]);
                var sig = await window.StacksProvider.authenticationRequest(rawtx)
                //code":-26,"message":"bad-witness-nonstandard
                
                redeemtx.input[0].witness = [ sig, script, cblock ];
                appendSighashType(sig, bitcoin.Transaction.SIGHASH_SINGLE | bitcoin.Transaction.SIGHASH_ANYONECANPAY)
                console.dir(redeemtx, { depth: null });
                var rawtx = BTON.Tx.encode(redeemtx);
                let txid = tran.getId()
                console.log('redeemtx: ' + txid);
                let psbt = new bitcoin.Psbt({ network: bitcoin.networks.bitcoin });



psbt.addInput({
    hash: txid,
    index: parseInt(ordinalUtxoVout),
    witnessUtxo : {
        script: scriptPubKeyFrom,
        value: amt
    },
    witness : [ sig, script, cblock ],
});

psbt.addOutput({
    address: from,
    value: price,
});
// Add the Tapleaf script signature
// Replace with the actual tapleaf script, control block, and signatures as necessary
const tapleafScript = Buffer.from(script, 'hex');
const controlBlock = Buffer.from(cblock, 'hex');
const signature = Buffer.from(sig, 'hex');

// Since we are using taproot, we need to use the taproot field names
psbt.updateInput(0, {
  taprootRedeemScript: tapleafScript,
  taprootPartialSig: [{ pubkey: controlBlock.slice(1), signature: signature }],
  taprootControlBlock: controlBlock,
});

console.log(psbt)
// sign psbt
psbt.finalizeAllInputs();   
console.log(psbt.toBase64())
// log psbt txid 

return [psbt.toBase64(),txid, sig]

}



            function encodeBase64( file ) {
                return new Promise( function( resolve, reject ) {
                    //the next three lines handle the case where an image is passed in from an external site
                
                    sessionStorage[ "mimetype" ] = file.type;
                    var imgReader = new FileReader();
                    imgReader.onloadend = function() {
                        resolve( imgReader.result.toString() );
                    }
                    imgReader.readAsDataURL( file );
                })

            }
            function base64ToHex(str) {
              var raw = atob(str);
              let result = '';
              for (let i = 0; i < raw.length; i++) {
                var hex = raw.charCodeAt(i).toString(16);
                result += (hex.length === 2 ? hex : '0' + hex);
              }
              return result.toLowerCase();
            }
            var price 
            function hexToBytes( hex ) {
                return Uint8Array.from( hex.match( /.{1,2}/g ).map( ( byte ) => parseInt( byte, 16 ) ) );
            }
            function bytesToHex( bytes ) {
                return bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, "0" ), "" );
            }
            function createQR( content ) {
                var dataUriPngImage = document.createElement( "img" ),
                s = QRCode.generatePNG( content, {
                    ecclevel: "M",
                    format: "html",
                    fillcolor: "#FFFFFF",
                    textcolor: "#000000",
                    margin: 4,
                    modulesize: 8,
                });
                dataUriPngImage.src = s;
                dataUriPngImage.id = "qr_code";
                return dataUriPngImage;
            }
            async function getBitcoinPriceFromCoinbase() {
                    var data = await getData( "https://api.coinbase.com/v2/prices/BTC-USD/spot" );
                    var json = JSON.parse( data );
                    var price = json[ "data" ][ "amount" ];
                    return price;
            }

            async function getBitcoinPriceFromKraken() {
                    var data = await getData( "https://api.kraken.com/0/public/Ticker?pair=XBTUSD" );
                    var json = JSON.parse( data );
                    var price = json[ "result" ][ "XXBTZUSD" ][ "a" ][ 0 ];
                    return price;
            }

            async function getBitcoinPriceFromCoindesk() {
                    var data = await getData( "https://api.coindesk.com/v1/bpi/currentprice.json" );
                    var json = JSON.parse( data );
                    var price = json[ "bpi" ][ "USD" ][ "rate_float" ];
                    return price;
            }

            async function getBitcoinPriceFromGemini() {
                    var data = await getData( "https://api.gemini.com/v2/ticker/BTCUSD" );
                    var json = JSON.parse( data );
                    var price = json[ "bid" ];
                    return price;
            }

            async function getBitcoinPriceFromBybit() {
                    var data = await getData( "https://api-testnet.bybit.com/derivatives/v3/public/order-book/L2?category=linear&symbol=BTCUSDT" );
                    var json = JSON.parse( data );
                    var price = json[ "result" ][ "b" ][ 0 ][ 0 ];
                    return price;
            }

            async function getBitcoinPrice() {
                var prices = [];
                var cbprice = await getBitcoinPriceFromCoinbase();
                var kprice = await getBitcoinPriceFromKraken();
                var cdprice = await getBitcoinPriceFromCoindesk();
                var gprice = await getBitcoinPriceFromGemini();
                var bprice = await getBitcoinPriceFromBybit();
                prices.push( Number( cbprice ), Number( kprice ), Number( cdprice ), Number( gprice ), Number( bprice ) );
                prices.sort();
                return prices[ 2 ];
            }
        </script>
    </head>
    <body>
        <h1>candies for sale RIGHT NOW!</h1>
        <div id="ordersContainer"
                        class="mt-4 flex-grid col-12 d-flex align-items-start justify-content-center">
                        <h6 class="text-gray my-5">Loading...</h6>
                    </div>
        <h1>Welcome to the online inscriber</h1>
        <h2 class="safari_warning">This tool may not work in safari browser. If you are using that, consider switching.</h2>
        <p>First enter a <span class="type_of_address">taproot</span> address from an ordinal wallet</p>
        <p><input class="address"></p>
        <p>Then upload a file you want that address to own</p>
        <form>
            <p><input type="file" class="form" multiple="true" /></p>
            <p>Select a Price for your Candies (measured in sats)</p>
            <p><input id="price"></p>
            <p>Select a feerate (measured in sats per byte)</p>
            <div class="feerates"><div class="fee minfee"><div class="num">...</div><div class="name">Min</div></div><div class="fee midfee"><div class="num">...</div><div class="name">Mid</div></div><div class="fee maxfee"><div class="num">...</div><div class="name">Max</div></div></div>
            <div id="sliderange">
                <p>Sats per byte: <span id="sats_per_byte">1</span></p>
                <input id="sats_range" type="range" min="1" max="100" value="1">
            </div>
            <script>
                var slider = document.getElementById( "sats_range" );
                var output = document.getElementById( "sats_per_byte" );
                output.innerHTML = slider.value;
                slider.oninput = function() {
                    output.innerHTML = this.value;
                    sessionStorage[ "feerate" ] = this.value;
                    $$( '.fee .num' ).forEach( function( item ) {
                        item.style.backgroundColor = "grey";
                    });
                }
            </script>
        </form>
        <p><button class="submit">Submit</button></p>
        <div class="display"></div>
        <div style="display: none;" class="file"></div>
        <script>
         

async function getInscriptionDataById(inscriptionId, verifyIsInscriptionNumber) {
    const html = await fetch(ordinalsExplorerUrl + "/inscription/" + inscriptionId)
        .then(response => response.text())

    const data = [...html.matchAll(/<dt>(.*?)<\/dt>\s*<dd.*?>(.*?)<\/dd>/gm)]
        .map(x => { x[2] = x[2].replace(/<.*?>/gm, ''); return x })
        .reduce((a, b) => { return { ...a, [b[1]]: b[2] } }, {});

    const error = `Inscription ${verifyIsInscriptionNumber || inscriptionId} not found (maybe you're on signet and looking for a mainnet inscription or vice versa)`
    try {
        data.number = html.match(/<h1>Inscription (\d*)<\/h1>/)[1]
    } catch { throw new Error(error) }
    if (verifyIsInscriptionNumber && String(data.number) != String(verifyIsInscriptionNumber)) {
        throw new Error(error)
    }

    return data
}
   
async function getWalletAddress() {
}
setTimeout (async function(){
let gwa = await getWalletAddress()
console.log('getWalletAddress', gwa)
})
async function signPSBTUsingWallet(input) {
console.log(1)
////fix error: Cannot read properties of undefined (reading 'script')

        
        let ahh = (await window.StacksProvider.transactionRequest(base64ToHex(input)))
        console.log(input)
        console.log(ahh)
console.log(2)
return ahh
}

function satsToFormattedDollarString(sats, _bitcoinPrice) {
    return (satToBtc(sats) * _bitcoinPrice).toLocaleString(undefined, {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    })
}

function sanitizeHTML(str) {
    var temp = document.createElement('div');
    temp.textContent = str;
    return temp.innerHTML;
}

async function* getLatestOrders(limit, nostrLimit = 20, filters = {}) {
console.log(1)
    if (window.NostrTools) {
                nostrRelay = window.NostrTools.relayInit(nostrRelayUrl)
                nostrRelay.connect()
            }
    await nostrRelay.connect()
    const latestOrders = []
    const inscriptionDataCache = {}

    const orders = await nostrRelay.list([{
        kinds: [nostrOrderEventKind],
        limit: nostrLimit,
        ...filters,
    }])

    for (const order of orders) {
        console.log(order)
        try {
           
            const redeem = order.tags.find(x => x?.[0] == 'i')[1]
            const price = order.tags.find(x => x?.[0] == 's')[1]
            const wallet = order.tags.find(x => x?.[0] == 'p')[1]
            const txid = order.tags.find(x => x?.[0] == 'u')[1]
           let leaf, cblock
            try {
             leaf = order.tags.find(x => x?.[0] == 'b')[1]
             cblock = order.tags.find(x => x?.[0] == 'c')[1]
        }
        catch (err){
            leaf = 0
            cblock = 0
        }

            let amt
            let sig 
            try { amt = order.tags.find(x => x?.[0] == 'a')[1]
        }
        catch (err){
            sig = 0
        }

            try { sig = order.tags.find(x => x?.[0] == 'l')[1]
        }
        catch (err){
            amt = 0
        }

const validatedPrice = parseInt(price || 0)
            if (!validatedPrice) {
                continue
            }

            bitcoinPrice = fetch(bitcoinPriceApiUrl)
        .then(response => response.json())
        .then(data => data.USD.last)

            const ord = {
                title: `Mint for for ${satToBtc(validatedPrice)} BTC ($${satsToFormattedDollarString(validatedPrice, await bitcoinPrice)})`,
                number: redeem,
                wallet,
                psbt: order.content,
                txid,

                amt, sig,  leaf, cblock
            }
            console.log(ord)
            latestOrders.push(ord)
            yield ord

            if (latestOrders.length >= limit) {
                break
            }
        } catch (e) {
            console.error(e)
        }
    }

    return latestOrders
}
async function loadLatestOrders(limit = 8, nostrLimit = 25) {
    try {
        const orders = getLatestOrders(limit, nostrLimit)

        const ordersContainer = document.getElementById('ordersContainer')
        ordersContainer.innerHTML = ''

        for await (const order of orders) {
            const orderElement = document.createElement('div')
            orderElement.onclick = function(){doit( order.psbt, order.amt);}
            orderElement.innerHTML = `
                <div class="card card-tertiary w-100 fmxw-300">
                    <div class="card-header text-center">
                        <span>Candy by #${order.wallet}</span>
                    </div>
                    <div class="card-body" style="padding: 6px 7px 7px 7px">
                       
                        <button class="btn btn-block btn-primary mt-2" style="max-width:185px; max-height: revert">${sanitizeHTML(order.title)}</button>
                    </div>
                </div>`
            ordersContainer.appendChild(orderElement)
        }
    } catch (e) {
        console.error(e)
        console.error(`Error fetching orders:\n` + e.message)
    }
}
setTimeout(async function(){

console.log(await loadLatestOrders())
})
async function doit(p, aamnt) {

var bitcoin = window.bitcoin 

            bitcoin.initEccLib(secp256k1)
    window.Buffer = Buffer;
    
let psbts = [p]
/* add these inputs 
-inputs-
0: payment
1: reveal
2: fees */
let inputs = []
let outputs = []
let psbt =  bitcoin.Psbt.fromBase64(psbts[0])
console.log(psbt)
let amt = 0
let fee = 0

let walletAddress = await getWalletAddress()
// for 40000 sats 
// create payment tx 
//bitcoin.TransactionBuilder is not a constructor
// add two dummy utxos 
var paymenttx = new bitcoin.Transaction()
console.log(psbt)
var utxos = await getAddressUtxos   (walletAddress)
var utxo = utxos[0]
var utxoTx = await getTxHexById(utxo.txid)
var utxoTx = bitcoin.Transaction.fromHex(utxoTx)
var utxoTx = utxoTx.outs[utxo.vout]
var utxoTx = { hash: utxo.txid, index: utxo.vout, witnessUtxo: utxoTx, value: aamnt + 20000}
for (const output in utxoTx.outs) {
    try { tx.setWitness(parseInt(output), []) } catch { }
}

inputs.push(utxoTx)

let feeRate = 11
//inputs.push(revealtxinput)
// add fees input of 20000 sats
console.log(psbt)
// add inputs to psbt

// add dummy output
psbt.addOutput({
    address: walletAddress,
    value: 0
})
var asktxtx = new bitcoin.Transaction()
console.log(psbt)
asktxtx.addOutput(psbt.data.globalMap.unsignedTx.tx.outs[0].script, psbt.data.globalMap.unsignedTx.tx.outs[0].value)

let asktxid = asktxtx.getId()
let asktxhex = asktxtx.toHex()
let asktxvout = 0
let asktxscript = asktxtx.outs[0].script
let asktxamount = psbt.data.globalMap.unsignedTx.tx.outs[0].value
for (const output in asktxtx.outs) {
    try { tx.setWitness(parseInt(output), []) } catch { }
}

let asktxtxoutput = { hash: asktxid, index: asktxvout,  nonWitnessUtxo: Buffer.from(asktxhex, 'hex') }
// add dummy output


const atx = bitcoin.Transaction.fromHex(await getTxHexById(atxid))
console.log(atx)
outputs.push({
    script: atx.outs[0].script,
    value: atx.outs[0].value
})

var totalInputValue = 0

for (let i = 0; i < inputs.length; i++) {
    if (inputs[i].witnessUtxo) {
        totalInputValue += inputs[i].witnessUtxo.value
    } else if (inputs[i].nonWitnessUtxo) {
        try {
            totalInputValue += inputs[i].nonWitnessUtxo.outs[inputs[i].index].value
        } catch (e) {
            console.log(e)
        }
    }
}
console.log(inputs)
console.log(totalInputValue)
var totalOutputValue = outputs.reduce((sum, output) => sum + output.value, 0);
console.log(totalOutputValue)

var estimatedFee = estimateTxSize(inputs.length, outputs.length + 1, feeRate);
console.log(estimatedFee)

var change = (totalInputValue - totalOutputValue - estimatedFee)
var toutputs = []
let wallet_address_script = bitcoin.address.toOutputScript(walletAddress, bitcoin.networks.bitcoin)
if (change > 0) {
    toutputs.push({
        script: wallet_address_script,
        value: change
    })
}
toutputs.push(psbt.data.globalMap.unsignedTx.tx.outs[0])
toutputs.push(outputs[0])

outputs = toutputs 
console.log(outputs)

for (let i = 0; i < inputs.length; i++) {
    console.log(inputs[i])
    psbt.addInput(inputs[i])
}

// add outputs to psbt
for (let i = 0; i < outputs.length; i++) {
    console.log(outputs[i])
    psbt.addOutput(outputs[i])
}   

console.log(psbt)
// sign psbt
psbt.finalizeAllInputs();

// Extract the signed transaction from the PSBT
const signedTransaction = psbt.extractTransaction();

// Get the raw transaction hex to broadcast
const rawTransactionHex = signedTransaction.toHex();
}
var cblock, leaf
let psbts = []
for (var psbt of pbsts){

    new Promise(async (resolve, reject) => {
                try {
            let apbst = await getTxHexById(psbt)
             apsbt = bitcoin.Psbt.fromHex(apbst).toBase64()
            
            if (window.NostrTools) {
                nostrRelay = window.NostrTools.relayInit(nostrRelayUrl)
                nostrRelay.connect()
            }
            
                    await nostrRelay.connect()
        
                    let sk = window.NostrTools.generatePrivateKey()
                    let pk = window.NostrTools.getPublicKey(sk)
        
                    let event = {
                        kind: nostrOrderEventKind,
                        pubkey: pk,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: [
                    ['n', "mainnet"], // Network name (e.g. "mainnet", "signet")
                    ['t', 'sell'], // Type of order (e.g. "sell", "buy")
                    ['s', price.toString()], // Price in sats
                    ['p', await getWalletAddress()],
                    ['x', "candyMachine"], // Exchange name (e.g. "openordex")
                        ],
                        content: apsbt,
                    }
                    console.log(event)
                    event.id = window.NostrTools.getEventHash(event)
                    event.sig = window.NostrTools.signEvent(event, sk)
        
                    let pub = nostrRelay.publish(event)
                    pub.on('ok', () => {
                        console.log(`${nostrRelay.url} has accepted our order`)
                        resolve()
                    })
                    pub.on('failed', reason => {
                        reject(`Failed to publish PSBT to ${relay.url}: ${reason}`)
                    })
                } catch (e) {
                    reject(e)
                }
            })
}
async function signPSBTUsingWalletAndBroadcast(input) {
console.log((input))

        var signedPsbt = await window.StacksProvider.transactionRequest(base64ToHex(input))
        var signedPsbt = bitcoin.Psbt.fromBase64(input)
        // finalize input s
        console.log(123)
        signedPsbt.finalizeAllInputs()

        console.log(321)
        const txHex = signedPsbt.extractTransaction().toHex()
let baseMempoolApiUrl = "https://mempool.space/api"
        const res = await fetch(`${baseMempoolApiUrl}/tx`, { method: 'post', body: txHex })
        if (res.status != 200) {
            return alert(`Mempool API returned ${res.status} ${res.statusText}\n\n${await res.text()}`)
        }

        const txId = res.text()
        alert('Transaction signed and broadcasted to mempool successfully')
        window.open(`${baseMempoolUrl}/tx/${txId}`, "_blank")
     
    
}
            sessionStorage.clear();
            var privkey = bytesToHex( cryptoUtils.Noble.utils.randomPrivateKey() );
            $( '.form' ).addEventListener( "change", async function() {

            })
                var KeyPair = cryptoUtils.KeyPair;
                var seckey = new KeyPair(privkey);
                var pubkey   = seckey.pub.rawX;
                
            $( '.submit' ).addEventListener( "click", async function() {
                var hexs = []
                var leafs = [];
                for (var file of $( '.form' ).files){
                
                    var b64 = await encodeBase64( file );
                
                var base64 = b64.substring( b64.indexOf( "base64," ) + 7 );
                var hex = base64ToHex( base64 );
                // console.log( "hex:", hex );
                // console.log( "bytes:", hexToBytes( hex ) );
                $( '.file' ).innerText = hex;
                var ec = new TextEncoder();
                var hex = $( '.file' ).innerText;
                var data = hexToBytes( hex );
                var mimetype = ec.encode( sessionStorage[ "mimetype" ] );
                var script   = [ pubkey, 'OP_CHECKSIG', 'OP_0', 'OP_IF', ec.encode('ord'), '01', mimetype, 'OP_0', data, 'OP_ENDIF' ];
                 leaf       = await BTON.Tap.getLeaf(BTON.Script.encode(script));
                leafs.push(leaf)
                hexs.push(hex)
                }
                var [ tapkey ] = await BTON.Tap.getPubkey(pubkey,leafs);
                 cblock     = await BTON.Tap.getPath(pubkey, leaf);
                console.log('Tapkey:', tapkey);
                var fundingAddress = BTON.Tap.encodeAddress( tapkey, 'bc');
                console.log('Funding address: ', fundingAddress );
                //var toAddress = prompt( "give me the address you your inscription to arrive in and consider using this one: tb1padwymyc6x2dfc3cwzvpxxcqsr3c46cjx9zxg0jmcuf44fjuwljxs7x68fm" );
                //var toAddress = "tb1padwymyc6x2dfc3cwzvpxxcqsr3c46cjx9zxg0jmcuf44fjuwljxs7x68fm";
                var toAddress = $( '.address' ).value;
                console.log('Address that will receive the inscription:', toAddress );
                var decodedToAddress = "5120" + BTON.Tap.decodeAddress( toAddress ).hex;
                var decodedFundingAddress = "5120" + BTON.Tap.decodeAddress( fundingAddress ).hex;
                console.log('To address decoded:', decodedToAddress );
                var t = 0 ;
                for (var h of hexs){
                    t+=h.length / 2
                }
                var txsize = 200 + t;
                if ( sessionStorage[ "feerate" ] ) {
                    var feerate = Number( sessionStorage[ "feerate" ] );
                } else {
                    var feerate = await getMaxFeeRate();
                }
                var fee = feerate * txsize;
                var btc_price = sessionStorage[ "bitcoin_price" ];
                var sats_price = await satsToDollars( fee + 1000 );
                sats_price = Math.floor( sats_price * 100 ) / 100;
                var html = `<p>Please send at least ${fee + 1000} sats ($${sats_price}) to this address:</p><p>${fundingAddress}</p>`;
                $( '.display' ).innerHTML = html;
                var qr_value = "bitcoin:" + fundingAddress + "?amount=" + satsToBitcoin( fee + 1000 );
                console.log( "qr:", qr_value );
                $( '.display' ).append( createQR( qr_value ) );
                $( '.display' ).innerHTML += `<p class="checking_mempool">Checking the mempool<span class="dots">.</span></p>`;
                $( '.display' ).innerHTML += `<p>1000 sats will go to the address</p><p>${fee} sats will go to miners as a mining fee</p>`;
                $( '.display' ).style.display = "block";
                await loopTilAddressReceivesMoney( fundingAddress );
                await waitSomeSeconds( 2 );
                var txinfo = await addressReceivedMoneyInThisTx( fundingAddress );
                var txid = txinfo[ 0 ];
                var a ;
                for (var a in leafs){
                }
                var amt = txinfo[ parseInt(a)+2 ];
                for (var a in leafs){
                var vout = txinfo[ parseInt(a)+1 ]; 
                // if ( !txid || !vout || !amt ) {
                //     await waitSomeSeconds( 2 );
                //     txinfo = await addressReceivedMoneyInThisTx( fundingAddress );
                //     txid = txinfo[ 0 ];
                //     vout = txinfo[ 1 ];
                //     amt = txinfo[ 2 ];
                // }
                // var amt = prompt( "give me the amount you sent" );
                // amt = Number( amt );
                // var txid = prompt( "give me the txid" );
                // var vout = prompt( "give me the vout" );
                // vout = Number( vout );
                console.log( "yay! txid:", txid, "vout:", vout );
                if ( sessionStorage[ "feerate" ] ) {
                    feerate = Number( sessionStorage[ "feerate" ] );
                } else {
                    feerate = await getMaxFeeRate();
                }
                var fee = feerate * txsize;
                console.log( "feerate:", feerate, "txsize:", txsize, "fee:", fee );
                console.log( "fee:", fee );
                price = parseInt(document.getElementById( "price" ).value)
console.log(price)
                var [apsbt, redeemtx, sig] = await generatePSBTListingInscriptionForSale(KeyPair,fundingAddress, txid, vout, amt, price , decodedFundingAddress, tapkey, leafs[a], decodedToAddress, decodedFundingAddress, fee, seckey, script, cblock);
                console.log(1)
                
                console.log('apsbt:', apsbt)
                var html = `<p style="background-color: white; color: black;">Success! Your image will shortly be inscribed on the bitcoin blockchain in this transaction:</p><p style="word-wrap: break-word;"><a href="https://mempool.space/tx/${txid}" target="_blank">https://mempool.space/tx/${txid}</a></p>`;
                html += `<p style="background-color: white; color: black;">When your transaction confirms you can view it on the ordinals explorer here:</p><p style="word-wrap: break-word;"><a href="http://staccstacc.eastus.cloudapp.azure.com/inscription/${txid}i0" target="_blank">http://staccstacc.eastus.cloudapp.azure.com/inscription/${txid}i0</a></p>`;
                $( '.modal' ).innerHTML = html;
                $( '.modal' ).style.display = "block";
                $( '.black-bg' ).style.display = "block";


            }
            });
            async function getMaxFeeRate() {
                var fees = await getData( "https://mempool.space/api/v1/fees/recommended" );
                fees = JSON.parse( fees );
                // if ( !( "minimumFee" in fees ) ) return "error -- site down";
                // var minfee = fees[ "minimumFee" ];
                if ( !( "fastestFee" in fees ) ) return "error -- site down";
                var minfee = fees[ "fastestFee" ];
                return minfee;
            }
            function isValidTaprootAddress( address ) {
                try {
                    BTON.Tap.decodeAddress( address ).hex;
                    return true;
                } catch( e ) {}
                return;
            }
            async function getAllFeeRates() {
                var fees = await getData( "https://mempool.space/api/v1/fees/recommended" );
                fees = JSON.parse( fees );
                return fees;
            }
            function getData( url ) {
                return new Promise( async function( resolve, reject ) {
                    function inner_get( url ) {
                        var xhttp = new XMLHttpRequest();
                        xhttp.open( "GET", url, true );
                        xhttp.send();
                        return xhttp;
                    }
                    var data = inner_get( url );
                    data.onerror = function( e ) {
                        resolve( "error" );
                    }
                    async function isResponseReady() {
                        return new Promise( function( resolve2, reject ) {
                            if ( !data.responseText || data.readyState != 4 ) {
                                setTimeout( async function() {
                                    var msg = await isResponseReady();
                                    resolve2( msg );
                                }, 1 );
                            } else {
                                resolve2( data.responseText );
                            }
                        });
                    }
                    var returnable = await isResponseReady();
                    resolve( returnable );
                });
            }
            async function  pushBTCpmt( rawtx ) {
                var txid = await postData( "https://mempool.space/api/tx", rawtx );
                return txid;
            }
            function waitSomeSeconds( num ) {
                var num = num.toString() + "000";
                num = Number( num );
                return new Promise( function( resolve, reject ) {
                    setTimeout( function() { resolve( "" ); }, num );
                });
            }
            async function postData( url, json, content_type = "", apikey = "" ) {
                var rtext = "";
                function inner_post( url, json, content_type = "", apikey = "" ) {
                    var xhttp = new XMLHttpRequest();
                    xhttp.open( "POST", url, true );
                    if ( content_type ) {
                        xhttp.setRequestHeader( `Content-Type`, content_type );
                    }
                    if ( apikey ) {
                        xhttp.setRequestHeader( `X-Api-Key`, apikey );
                    }
                    xhttp.send( json );
                    return xhttp;
                }
                var data = inner_post( url, json, content_type, apikey );
                data.onerror = function( e ) {
                    rtext = "error";
                }
                async function isResponseReady() {
                    return new Promise( function( resolve, reject ) {
                        if ( rtext == "error" ) {
                            resolve( rtext );
                        }
                        if ( !data.responseText || data.readyState != 4 ) {
                            setTimeout( async function() {
                                var msg = await isResponseReady();
                                resolve( msg );
                            }, 50 );
                        } else {
                            resolve( data.responseText );
                        }
                    });
                }
                var returnable = await isResponseReady();
                return returnable;
            }
            async function loopTilAddressReceivesMoney( address ) {
              var itReceivedMoney = false;
              async function isDataSetYet( data_i_seek ) {
                return new Promise( function( resolve, reject ) {
                  if ( !data_i_seek ) {
                    setTimeout( async function() {
                      console.log( "waiting for address to receive money..." );
                      itReceivedMoney = await addressOnceHadMoney( address );
                      var msg = await isDataSetYet( itReceivedMoney );
                      resolve( msg );
                    }, 2000 );
                  } else {
                    resolve( data_i_seek );
                  }
                });
              }
              async function getTimeoutData() {
                var data_i_seek = await isDataSetYet( itReceivedMoney );
                return data_i_seek;
              }
              var returnable = await getTimeoutData();
              return returnable;
            }

            async function addressReceivedMoneyInThisTx( address ) {
              var txid;
              var vout;
              var amt;
              var nonjson = await getData( "https://mempool.space/api/address/" + address + "/txs" );
              var json = JSON.parse( nonjson );
              var vouts = []
              json.forEach( function( tx ) {
                tx[ "vout" ].forEach( function( output, index ) {
                  if ( output[ "scriptpubkey_address" ] == address ) {
                    txid = tx[ "txid" ];
                    vout = index;
                    vouts.push(vout)
                    amt = output[ "value" ];
                  }
                });
              });
              return [txid, ...vouts, amt];
            }
            async function addressOnceHadMoney( address ) {
                var url = "https://mempool.space/api/address/" + address;
                var nonjson = await getData( url );
                var json = JSON.parse( nonjson );
                if ( json[ "chain_stats" ][ "tx_count" ] > 0 || json[ "mempool_stats" ][ "tx_count" ] > 0 ) {
                    return true;
                }
                return false;
            }
            function dotLoop( string ) {
                if ( !$( '.dots' ) ) {
                    setTimeout( function() {dotLoop( string );}, 1000 );
                    return;
                }
                if ( string.length < 3 ) {
                    string = string + ".";
                } else {
                    string = ".";
                }
                $( '.dots' ).innerText = string;
                setTimeout( function() {dotLoop( string );}, 1000 );
            }
            dotLoop( "." );
            function satsToBitcoin( sats ) {
                if ( sats >= 100000000 ) sats = sats * 10;
                var string = String( sats ).padStart( 8, "0" ).slice( 0,-9 ) + "." + String( sats ).padStart( 8, "0" ).slice( -9 );
                if ( string.substring( 0, 1 ) == "." ) string = "0" + string;
                return string;
            }

            async function satsToDollars( sats ) {
                if ( sats >= 100000000 ) sats = sats * 10;
                var bitcoin_price = sessionStorage[ "bitcoin_price" ];
                var value_in_dollars = Number( String( sats ).padStart( 8, "0" ).slice( 0,-9 ) + "." + String( sats ).padStart( 8, "0" ).slice( -9 ) ) * bitcoin_price;
                return value_in_dollars;
            }
            function modalVanish() {
                $( ".black-bg" ).style.display = "none";
                $( ".modal" ).style.display = "none";
            }
            $$( '.fee' ).forEach( function( item ) {
                item.onclick = function() {
                    $$( '.fee .num' ).forEach( function( item2 ) {
                        item2.style.backgroundColor = "grey";
                    });
                    this.getElementsByClassName( "num" )[ 0 ].style.backgroundColor = "green";
                    sessionStorage[ "feerate" ] = this.getElementsByClassName( "num" )[ 0 ].innerText;
                    $( '#sats_per_byte' ).innerText = Number( this.getElementsByClassName( "num" )[ 0 ].innerText );
                    $( '#sats_range' ).value = Number( this.getElementsByClassName( "num" )[ 0 ].innerText );
               0 }
            });
            function checkAddress() {
                if ( !isValidTaprootAddress( $( '.address' ).value ) && $( '.address' ).value ) {
                    $( '.address' ).style.backgroundColor = "#ff5252";
                    $( '.address' ).style.border = "2px solid red";
                    $( '.type_of_address' ).style.border = "1px solid white";
                } else {
                    $( '.address' ).style.backgroundColor = "initial";
                    $( '.address' ).style.border = "1px solid white";                    
                    $( '.type_of_address' ).style.borderStyle = "none";
                }
            }
            $( '.address' ).onchange = checkAddress;
            $( '.address' ).onpaste = checkAddress;
            $( '.address' ).onkeyup = checkAddress;
            async function init( num ) {
                if ( !num ) {
                    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                    if ( isSafari ) $( '.safari_warning' ).style.display = "block";
                    var maxfee = await getMaxFeeRate();
                    $( '#sats_per_byte' ).innerText = maxfee;
                    $( '#sats_range' ).value = maxfee;
                }
                num = num + 1;
                var allrates = await getAllFeeRates();
                $( '.minfee .num' ).innerText = allrates[ "minimumFee" ];
                $( '.midfee .num' ).innerText = allrates[ "hourFee" ];
                $( '.maxfee .num' ).innerText = allrates[ "fastestFee" ];
                sessionStorage[ "bitcoin_price" ] = await getBitcoinPrice();
                await waitSomeSeconds( 10 );
                init( num );
            }
            init( 0 );
        </script>
        <div class="black-bg" onclick="modalVanish();"></div>
        <div class="modal"></div>
    </body>
</html>
